<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <!--Include Scripts-->
    <script src="three.js" ></script>
    <script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
    <script src="StereoEffect.js"></script>
    <script src="VRControls.js"></script>
    <script src="VREffect.js"></script>
    <script src="DeviceOrientationControls.js"></script>
    <!--End of Include Scripts-->

    <!--Inline Shaders-->
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        void main()
        {
            vNormal = normalize( normalMatrix * normal );
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-pixel">
        varying vec3 vNormal;
        void main()
        {
            float intensity = pow( 0.27 - dot( vNormal, vec3( 0.0, 0.0, 1.0 ) ), 4.1 );
            gl_FragColor = vec4( 189.0 / 255.0, 190.0 / 255.0, 192.0 / 255.0, 1.0 ) * intensity;
        }
    </script>
    <!--End of Inline Shaders-->

    <!--Custom JS for definitions-->
    <script src="js/DS.js"></script>
    <script src="js/Constants.js"></script>
    <!--End of Custom SScripts-->
    <script>
        var controls = null;

        // Start
        this.onload = function () {
            // Global vars
            var scene, camera, renderer;
            var mesh2, mesh3;
            var moonMesh = null;
            
            // Global Geometry
            var geometry = null;
            var sunGrp = null;
            var FAR = 1000;
            init();
            animate();
            setTimeout(animate(), 1000 / 60);
            function init() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);
                camera.position.z = FAR;

                // Lights
                var dirLight = new THREE.DirectionalLight(0xffffff, 0.35);
                dirLight.position.set(0, 1, 1).normalize();
                scene.add(dirLight);

                geometry = new THREE.CubeGeometry(200, 200, 200);
                
                geometry = new THREE.SphereGeometry(250, 100, 100);
                var sphereMaterial = new THREE.MeshPhongMaterial({
                    map: new THREE.ImageUtils.loadTexture('Textures/earth.jpg'),
                    specularMap: new THREE.ImageUtils.loadTexture('Textures/earthSpec.jpg'),
                    specular: new THREE.Color('white'),
                    bumpScale: 35,
                    skinning: false,
                    refractionRatio: 0.05,
                    bumpMap: new THREE.ImageUtils.loadTexture('Textures/earthNormal.jpg'),
                    color: 0xffffff,
                    wireframe: false,
                    ambient: 0x050505,
                    specular: 0x555500,
                    shininess: 0.05
                });
                mesh2 = new THREE.Mesh(geometry, sphereMaterial);
                mesh2.position.set(-300, 0, 0);
                scene.add(mesh2);

                // Moon and group setting
                geometry = new THREE.SphereGeometry(85, 100, 100);
                var moonTex = new THREE.MeshPhongMaterial({
                    map: new THREE.ImageUtils.loadTexture('Textures/moonTex.jpg'),
                    specular: new THREE.Color('grey'),
                    bumpScale: 10,
                    bumpMap: new THREE.ImageUtils.loadTexture('Textures/moonNor.jpg'),
                    color: 0xffffff,
                    wireframe: false,
                    ambient: 0x050505,
                    specular: 0x555555,
                    shininess: 10
                });
                moonMesh = new THREE.Mesh(geometry, moonTex);               
                moonMesh.position.set(-600, -500, 0);
                scene.add(moonMesh);

                //Sun Glow
                var customMaterial = new THREE.ShaderMaterial(
	                                {
	                                    uniforms: {},
	                                    vertexShader: document.getElementById('vertexShader').textContent,
	                                    fragmentShader: document.getElementById('fragmentShader').textContent,
	                                    side: THREE.BackSide,
	                                    blending: THREE.AdditiveBlending,
	                                    transparent: true
	                                });

                var ballGeometry = new THREE.SphereGeometry(3000, 100, 100);
                var ball = new THREE.Mesh(ballGeometry, customMaterial);
                var ptLight = new THREE.PointLight(0xafafaf, 2, 100000);
                
                sunGrp = new THREE.Group();
                sunGrp.position.set(-10000, 50, 350);
                sunGrp.add(ball);
                sunGrp.add(ptLight);
                scene.add(sunGrp);

                //skybox stuff
                var cubemap = THREE.ImageUtils.loadTextureCube(skyboxSrc); // load textures
                cubemap.format = THREE.RGBFormat;
                var shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
                shader.uniforms['tCube'].value = cubemap; // apply textures to shader
                var skyBoxMaterial = new THREE.ShaderMaterial({
                    fragmentShader: shader.fragmentShader,
                    vertexShader: shader.vertexShader,
                    uniforms: shader.uniforms,
                    depthWrite: false,
                    side: THREE.BackSide
                });
                var skybox = new THREE.Mesh(
                      new THREE.CubeGeometry(100000, 100000, 100000),
                      skyBoxMaterial
                    );

                scene.add(skybox);

                //end skybox
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);

                document.body.appendChild(renderer.domElement);
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.addEventListener('change', render);
                this.onresize = onWindowResize;
            }


            // Event Handlers
            var oldPosition = null;
            function onMouseDown() {
                var e = window.event;
                var posX = e.clientX;
                var posY = e.clientY;
                var mousePosition = new Vector2(posX, posY);
                if( oldPosition != null )
                {
                    //mesh2.rotateY((mousePosition.getX() - oldPosition.getX()) / 1000);
                    //mesh2.rotateX((mousePosition.getY() - oldPosition.getY()) / 1000);
                    
                    console.log('New Postion : ' + mousePosition.getX());
                    console.log('Old Postion : ' + oldPosition.getX());
                    oldPosition = mousePosition;
                }
                else {
                    oldPosition = mousePosition
                }
            }

            function onScroll(a) {
                // console.log(a);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                render();
            }


            //Rendering.
            function animate() {
                requestAnimationFrame(animate);
                mesh2.rotation.x += 0.0004;
                mesh2.translateX(0.00001);
                mesh2.translateY(0.000005);
                mesh2.rotation.y += 0.002;
                controls.update();
                render();
            }
            function render() {
                renderer.render(scene, camera);
            }
        }
    </script>
</head>
<body>

</body>
</html>
